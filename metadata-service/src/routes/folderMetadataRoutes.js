/**
 * Folder Metadata Routes
 * 
 * These endpoints handle folder metadata CRUD operations for the Cloud Drive.
 * Called by the File Management Service to manage folder hierarchy.
 * 
 * Routes:
 * - POST   /api/folders                    - Create folder
 * - GET    /api/folders                    - List user's folders
 * - GET    /api/folders/:folderId          - Get folder info
 * - GET    /api/folders/:folderId/content  - List folder contents (subfolders + files)
 * - POST   /api/folders/:folderId/move     - Move folder to another folder
 * - DELETE /api/folders/:folderId          - Delete folder (recursive)
 */

const express = require('express');
const router = express.Router();
const { DynamoDBClient } = require('@aws-sdk/client-dynamodb');
const { 
    DynamoDBDocumentClient, 
    PutCommand, 
    GetCommand, 
    UpdateCommand, 
    DeleteCommand,
    QueryCommand,
    ScanCommand
} = require('@aws-sdk/lib-dynamodb');

// Initialize DynamoDB client
const client = new DynamoDBClient({
    region: process.env.AWS_REGION || 'us-east-1'
});
const docClient = DynamoDBDocumentClient.from(client);

const TABLE_NAME = process.env.TABLE_NAME || 'cloud-drive-files';

// ============================================
// POST /api/folders - Create folder
// ============================================
/**
 * Create a new folder.
 * 
 * Request body: {
 *   folderId: string,    // Unique folder ID (generated by file-management)
 *   userId: string,      // Owner user ID
 *   name: string,        // Folder name
 *   parentId: string     // Parent folder ID ("root" for root level)
 * }
 */
router.post('/', async (req, res) => {
    try {
        const {
            folderId,
            userId,
            name,
            parentId = 'root',
            createdAt,
            updatedAt
        } = req.body;

        // Validate required fields
        if (!folderId || !userId || !name) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'folderId, userId, and name are required'
            });
        }

        // Check if parent folder exists (if not root)
        if (parentId !== 'root') {
            const parentResult = await docClient.send(new GetCommand({
                TableName: TABLE_NAME,
                Key: { fileId: parentId }
            }));

            if (!parentResult.Item || parentResult.Item.type !== 'folder') {
                return res.status(404).json({
                    error: 'Not Found',
                    message: 'Parent folder not found'
                });
            }

            // Ensure parent belongs to same user
            if (parentResult.Item.userId !== userId) {
                return res.status(403).json({
                    error: 'Forbidden',
                    message: 'Cannot create folder in another user\'s folder'
                });
            }
        }

        const timestamp = new Date().toISOString();

        // Create folder object
        // Note: We use fileId as the primary key for folders too (for consistency)
        const folder = {
            fileId: folderId,           // Use fileId as PK (same as files)
            folderId,                   // Keep folderId for clarity
            userId,
            name,
            nameLower: name.toLowerCase(), // For case-insensitive search
            parentId,
            type: 'folder',             // Distinguish from files
            createdAt: createdAt || timestamp,
            updatedAt: updatedAt || timestamp
        };

        // Store in DynamoDB
        await docClient.send(new PutCommand({
            TableName: TABLE_NAME,
            Item: folder,
            ConditionExpression: 'attribute_not_exists(fileId)'
        }));

        console.log(`[FOLDER] Created folder: ${name} (${folderId})`);

        res.status(201).json({
            message: 'Folder created successfully',
            folder: {
                folderId,
                userId,
                name,
                parentId,
                createdAt: folder.createdAt,
                updatedAt: folder.updatedAt
            }
        });

    } catch (error) {
        console.error('[FOLDER] Create error:', error);

        if (error.name === 'ConditionalCheckFailedException') {
            return res.status(409).json({
                error: 'Conflict',
                message: 'Folder with this ID already exists'
            });
        }

        res.status(500).json({
            error: 'Internal Server Error',
            message: 'Failed to create folder'
        });
    }
});

// ============================================
// GET /api/folders - List all user's folders
// ============================================
/**
 * List all folders for a user.
 * Used for folder selection dropdowns (e.g., move file to folder).
 * 
 * Query params:
 * - userId: Required
 */
router.get('/', async (req, res) => {
    try {
        const { userId } = req.query;

        if (!userId) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'userId query parameter is required'
            });
        }

        // Query all folders for this user using GSI
        const result = await docClient.send(new QueryCommand({
            TableName: TABLE_NAME,
            IndexName: 'userId-createdAt-index',
            KeyConditionExpression: 'userId = :userId',
            FilterExpression: '#type = :type',
            ExpressionAttributeNames: {
                '#type': 'type'
            },
            ExpressionAttributeValues: {
                ':userId': userId,
                ':type': 'folder'
            }
        }));

        const folders = (result.Items || []).map(item => ({
            folderId: item.folderId,
            userId: item.userId,
            name: item.name,
            parentId: item.parentId,
            createdAt: item.createdAt,
            updatedAt: item.updatedAt
        }));

        console.log(`[FOLDER] Listed ${folders.length} folders for user: ${userId}`);

        res.json({
            folders,
            count: folders.length
        });

    } catch (error) {
        console.error('[FOLDER] List error:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: 'Failed to list folders'
        });
    }
});

// ============================================
// GET /api/folders/:folderId - Get folder info
// ============================================
/**
 * Get a single folder's information.
 * Used for back navigation and folder details.
 */
router.get('/:folderId', async (req, res) => {
    try {
        const { folderId } = req.params;

        // Handle root folder specially
        if (folderId === 'root') {
            return res.json({
                folder: {
                    folderId: 'root',
                    name: 'My Drive',
                    parentId: null
                }
            });
        }

        const result = await docClient.send(new GetCommand({
            TableName: TABLE_NAME,
            Key: { fileId: folderId }
        }));

        if (!result.Item || result.Item.type !== 'folder') {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Folder not found'
            });
        }

        const folder = result.Item;

        res.json({
            folder: {
                folderId: folder.folderId,
                userId: folder.userId,
                name: folder.name,
                parentId: folder.parentId,
                createdAt: folder.createdAt,
                updatedAt: folder.updatedAt
            }
        });

    } catch (error) {
        console.error('[FOLDER] Get error:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: 'Failed to get folder'
        });
    }
});

// ============================================
// GET /api/folders/:folderId/content - List folder contents
// ============================================
/**
 * List all contents of a folder (subfolders + files).
 * This is the main API for browsing the file system.
 * 
 * Query params:
 * - userId: Required
 */
router.get('/:folderId/content', async (req, res) => {
    try {
        const { folderId } = req.params;
        const { userId } = req.query;

        if (!userId) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'userId query parameter is required'
            });
        }

        // Get all items for this user
        const result = await docClient.send(new QueryCommand({
            TableName: TABLE_NAME,
            IndexName: 'userId-createdAt-index',
            KeyConditionExpression: 'userId = :userId',
            ExpressionAttributeValues: {
                ':userId': userId
            },
            ScanIndexForward: false // Newest first
        }));

        const allItems = result.Items || [];

        // Filter subfolders (folders with parentId matching current folder)
        const folders = allItems
            .filter(item => item.type === 'folder' && item.parentId === folderId)
            .map(item => ({
                folderId: item.folderId,
                userId: item.userId,
                name: item.name,
                parentId: item.parentId,
                createdAt: item.createdAt,
                updatedAt: item.updatedAt
            }));

        // Filter files (files with folderId matching current folder)
        // For root folder, match folderId === 'root' or folderId === null
        const files = allItems
            .filter(item => {
                if (item.type === 'folder') return false;
                if (folderId === 'root') {
                    return !item.folderId || item.folderId === 'root' || item.folderId === null;
                }
                return item.folderId === folderId;
            })
            .map(item => ({
                fileId: item.fileId,
                userId: item.userId,
                filename: item.filename,
                mimeType: item.mimeType,
                size: item.size,
                folderId: item.folderId,
                isPublic: item.isPublic,
                currentVersion: item.currentVersion,
                createdAt: item.createdAt,
                updatedAt: item.updatedAt
            }));

        console.log(`[FOLDER] Content of ${folderId}: ${folders.length} folders, ${files.length} files`);

        res.json({
            folderId,
            folders,
            files,
            folderCount: folders.length,
            fileCount: files.length
        });

    } catch (error) {
        console.error('[FOLDER] Content error:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: 'Failed to get folder content'
        });
    }
});

// ============================================
// POST /api/folders/:folderId/move - Move folder
// ============================================
/**
 * Move a folder to another folder.
 * Validates that:
 * - Cannot move folder into itself
 * - Cannot move folder into its descendant (would create cycle)
 * - Target folder must belong to same user
 * 
 * Request body: {
 *   targetFolderId: string,  // Destination folder ID
 *   userId: string           // For validation
 * }
 */
router.post('/:folderId/move', async (req, res) => {
    try {
        const { folderId } = req.params;
        const { targetFolderId, userId } = req.body;

        // Cannot move root
        if (folderId === 'root') {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'Cannot move root folder'
            });
        }

        // Cannot move folder into itself
        if (folderId === targetFolderId) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'Cannot move folder into itself'
            });
        }

        // Get the folder being moved
        const folderResult = await docClient.send(new GetCommand({
            TableName: TABLE_NAME,
            Key: { fileId: folderId }
        }));

        if (!folderResult.Item || folderResult.Item.type !== 'folder') {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Folder not found'
            });
        }

        const folder = folderResult.Item;

        // Verify ownership
        if (folder.userId !== userId) {
            return res.status(403).json({
                error: 'Forbidden',
                message: 'Access denied'
            });
        }

        // If moving to a non-root folder, validate target
        if (targetFolderId !== 'root') {
            const targetResult = await docClient.send(new GetCommand({
                TableName: TABLE_NAME,
                Key: { fileId: targetFolderId }
            }));

            if (!targetResult.Item || targetResult.Item.type !== 'folder') {
                return res.status(404).json({
                    error: 'Not Found',
                    message: 'Target folder not found'
                });
            }

            // Ensure target belongs to same user
            if (targetResult.Item.userId !== userId) {
                return res.status(403).json({
                    error: 'Forbidden',
                    message: 'Cannot move into another user\'s folder'
                });
            }

            // Check for cycle: target cannot be a descendant of folder being moved
            const isDescendant = await checkIsDescendant(folderId, targetFolderId, userId);
            if (isDescendant) {
                return res.status(400).json({
                    error: 'Bad Request',
                    message: 'Cannot move folder into its own descendant'
                });
            }
        }

        // Update folder's parentId
        await docClient.send(new UpdateCommand({
            TableName: TABLE_NAME,
            Key: { fileId: folderId },
            UpdateExpression: 'SET parentId = :parentId, updatedAt = :updatedAt',
            ExpressionAttributeValues: {
                ':parentId': targetFolderId,
                ':updatedAt': new Date().toISOString()
            }
        }));

        console.log(`[FOLDER] Moved folder ${folderId} to ${targetFolderId}`);

        res.json({
            message: 'Folder moved successfully'
        });

    } catch (error) {
        console.error('[FOLDER] Move error:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: 'Failed to move folder'
        });
    }
});

/**
 * Helper: Check if targetId is a descendant of folderId
 * Used to prevent creating cycles when moving folders.
 */
async function checkIsDescendant(folderId, targetId, userId) {
    // Get all folders for this user
    const result = await docClient.send(new QueryCommand({
        TableName: TABLE_NAME,
        IndexName: 'userId-createdAt-index',
        KeyConditionExpression: 'userId = :userId',
        FilterExpression: '#type = :type',
        ExpressionAttributeNames: {
            '#type': 'type'
        },
        ExpressionAttributeValues: {
            ':userId': userId,
            ':type': 'folder'
        }
    }));

    const folders = result.Items || [];
    const folderMap = new Map(folders.map(f => [f.folderId, f]));

    // Walk up from target to see if we reach folderId
    let current = folderMap.get(targetId);
    while (current) {
        if (current.parentId === folderId) {
            return true;
        }
        current = folderMap.get(current.parentId);
    }

    return false;
}

// ============================================
// DELETE /api/folders/:folderId - Delete folder
// ============================================
/**
 * Delete a folder and all its contents recursively.
 * This will delete:
 * - All subfolders (recursively)
 * - All files in the folder and subfolders
 * 
 * Query params:
 * - userId: Required for validation
 */
router.delete('/:folderId', async (req, res) => {
    try {
        const { folderId } = req.params;
        const { userId } = req.query;

        // Cannot delete root
        if (folderId === 'root') {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'Cannot delete root folder'
            });
        }

        if (!userId) {
            return res.status(400).json({
                error: 'Bad Request',
                message: 'userId query parameter is required'
            });
        }

        // Get the folder being deleted
        const folderResult = await docClient.send(new GetCommand({
            TableName: TABLE_NAME,
            Key: { fileId: folderId }
        }));

        if (!folderResult.Item || folderResult.Item.type !== 'folder') {
            return res.status(404).json({
                error: 'Not Found',
                message: 'Folder not found'
            });
        }

        // Verify ownership
        if (folderResult.Item.userId !== userId) {
            return res.status(403).json({
                error: 'Forbidden',
                message: 'Access denied'
            });
        }

        // Get all descendant folder IDs
        const descendantIds = await getAllDescendants(folderId, userId);
        const allFolderIds = [folderId, ...descendantIds];

        // Get all items for this user to find files to delete
        const allItemsResult = await docClient.send(new QueryCommand({
            TableName: TABLE_NAME,
            IndexName: 'userId-createdAt-index',
            KeyConditionExpression: 'userId = :userId',
            ExpressionAttributeValues: {
                ':userId': userId
            }
        }));

        const allItems = allItemsResult.Items || [];

        // Find all files in these folders
        const filesToDelete = allItems.filter(item => 
            item.type !== 'folder' && allFolderIds.includes(item.folderId)
        );

        // Delete all files (metadata only - S3 deletion is handled by file-management)
        for (const file of filesToDelete) {
            await docClient.send(new DeleteCommand({
                TableName: TABLE_NAME,
                Key: { fileId: file.fileId }
            }));
        }

        // Delete all folders
        for (const id of allFolderIds) {
            await docClient.send(new DeleteCommand({
                TableName: TABLE_NAME,
                Key: { fileId: id }
            }));
        }

        console.log(`[FOLDER] Deleted folder ${folderId} with ${descendantIds.length} subfolders and ${filesToDelete.length} files`);

        res.json({
            message: 'Folder deleted successfully',
            deletedFolders: allFolderIds.length,
            deletedFiles: filesToDelete.length
        });

    } catch (error) {
        console.error('[FOLDER] Delete error:', error);
        res.status(500).json({
            error: 'Internal Server Error',
            message: 'Failed to delete folder'
        });
    }
});

/**
 * Helper: Get all descendant folder IDs recursively
 */
async function getAllDescendants(folderId, userId) {
    // Get all folders for this user
    const result = await docClient.send(new QueryCommand({
        TableName: TABLE_NAME,
        IndexName: 'userId-createdAt-index',
        KeyConditionExpression: 'userId = :userId',
        FilterExpression: '#type = :type',
        ExpressionAttributeNames: {
            '#type': 'type'
        },
        ExpressionAttributeValues: {
            ':userId': userId,
            ':type': 'folder'
        }
    }));

    const folders = result.Items || [];
    const descendants = [];

    function findChildren(parentId) {
        for (const folder of folders) {
            if (folder.parentId === parentId) {
                descendants.push(folder.folderId);
                findChildren(folder.folderId);
            }
        }
    }

    findChildren(folderId);
    return descendants;
}

module.exports = router;

